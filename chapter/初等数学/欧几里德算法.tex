\section{欧几里德算法}\label{sec:欧几里德算法}
在一般的环境中，我们可以使用 \cmd{\_\_gcd(x, g)} 直接求解，其代码约为：
\begin{Cpp}
int gcd(int a,int b){return a?gcd(b%a,a):b;}
\end{Cpp}

欧几里德同时也求出了 $ax + by$ 这个线性组合的最小解。为了得到 $x$ 和 $y$ 的值，
也可以使用更高级的扩展欧几里德（见章节 \ref{sec:扩展欧几里德}）。

\subsection{扩展欧几里德}\label{sec:扩展欧几里德}\label{subsec:扩展欧几里德}
简单的欧几里德求最大公约数可以参考 \ref{sec:欧几里德算法} 章中的相关代码。扩展欧
几里德不仅可以得到最大公约数，并且可以得到斐蜀定理（见章节 \ref{sec:裴蜀定理}）
中提到的 $x$ 和$y$ 的值。其代码如下：
\begin{Cpp}
int exgcd(int a,int b,int& x,int& y){
  if(!a){
    x=0,y=1;
    return b;
  }else{
    int res=exgcd(b%a,a,y,x);
    y-=(b/a)*x;
    return res;
  }
}
\end{Cpp}

我们也可以使用扩展欧几里德来求解逆元：如果模为 $b$，而我们要求 $a$ 在模 $b$ 意义
下的逆元的话，那么我们可以使用 \cmd{exgcd(a,b,x,y)}，如果返回的结果是 $1$ 的话，
那么说明它们满足：\[
    ax + by = 1
\]

变换到模意义下有：\[
    ax \equiv 1 \pmod b
\]

那么 $x$ 即为 $a$ 在模 $b$ 意义下的逆元。如果 $a$ 和 $b$ 互质的话，我们当然可以
用欧拉定理（见章节 \ref{sec:欧拉定理}）来求解逆元，不过这是吃力不讨好的事情。如
果 $b$ 本身是一个素数的话，那么我们可以直接使用费马小定理（见章节 \ref{sec:费马%
小定理}）。
