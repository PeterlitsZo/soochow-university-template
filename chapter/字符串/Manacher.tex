\section{Manacher --- 线性求回文}

惭愧。看了 LeetCode 中的一个题目，才发现自己曾经学过的知识已经忘记了一半了。

本问题也可以使用字符串哈希（见 \ref{sec:哈希}），后缀数组或者快速 LCA 来求解。

首先我们可以插空来磨平奇回文串和偶回文串之间的差异。

之后我们谈论如何线性求奇回文串。我们考虑朴素算法，来维护对于下标 $i$ 而言，延展
开的奇回文串的臂长 $d_i$ 有多长。自然奇回文串的长度为 $2 d_i - 1$。
\begin{Cpp}
// *警告*：这是 O(n*n) 的代码。
// 需要从 0 开始的臂长数组 d 和从 0 开始的字符
// 串 S。
{
  for(int i=0;i<n;i++){
    d[i]=1;
    while(0<=i-d[i]&&i+d[i]<n){
      // 不能扩展了！！
      if(S[i-d[i]]!=S[i+d[i]])break;
      // 能扩展！！
      d[i]++;
    }
  }
}
\end{Cpp}

但是大家！！！聪明的大家都知道这个复杂度不大对！！它的复杂度为 $\FnO(n^2)$！！

我们如果 $d_i$ 能利用 $d_j,\, j<i$ 就好了！！这是可行的，不过我们需要维护 $r$ 最
大的回文字符串的 $l$ 和 $r$。那么现在有两种情况：
\begin{enumerate}
    \item $i > r$，那么调用朴素算法即可。
    \item $i \le r$，那么在 $S(l..r)$ 字符串中对应的下标是 $j = l + r - i$。我们可能
        会成立等式 $d_i = d_j$。不过，如果 $j$ 对应的字符串可能超过了 $l$ 的边界
        ，这是不行的，等式可能就不会成立了！如果出现了这种问题，我们尝试缩小了它
        的臂长，然后再朴素地搞 $d_i$。
\end{enumerate}

每一次遍历完之后都要记得维护相应地值哦。

因此我们可以给出代码：
\begin{Cpp}
// 需要从 0 开始的臂长数组 d 和从 0 开始的字符
// 串 S。
{
  int l=-1,r=-1;
  for(int i=0;i<n;i++){
    int k=(i>r)?1:min(d[l+r-i]:r-i+1);
    while(0<=i-k&&i+k<n){
      // 不能扩展！！
      if(S[i-k]!=S[i+k])break;
      // 能扩展！！
      k++;
    }
    d[i] = k--;
    // 维护 l 和 r！！
    if(i+k>r) l=i-k, r=i+k;
  }
}
\end{Cpp}
